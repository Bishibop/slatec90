#!/usr/bin/env python3
"""
Enhanced Function Discovery Script for Zero-Maintenance Validator

This script automatically discovers modernized functions, reads their signatures,
and generates all necessary include files for the validator.
"""

import os
import glob
import re
import json
from pathlib import Path
from typing import Dict, List, Tuple

class FunctionDiscovery:
    def __init__(self, base_dir=None):
        if base_dir is None:
            self.script_dir = Path(__file__).parent
            self.base_dir = self.script_dir.parent
        else:
            self.base_dir = Path(base_dir)
            self.script_dir = self.base_dir / "fortran_validator"
            
        self.modern_dir = self.base_dir / "modern"
        self.src_dir = self.base_dir / "src"
        self.signatures_file = self.script_dir / "slatec_signatures_module.f90"
        
        # Signature type mappings
        self.sig_types = {
            1: "SIG_REAL_FUNC_1_INT",
            2: "SIG_REAL_FUNC_1_REAL", 
            3: "SIG_REAL_FUNC_2_REAL",
            4: "SIG_INT_FUNC_1_INT",
            5: "SIG_DOUBLE_FUNC_1_INT",
            6: "SIG_LOGICAL_FUNC_2_CHAR",
            7: "SIG_SUB_0_PARAMS",
            8: "SIG_SUB_1_CHAR_OUT",
            9: "SIG_SUB_6_REAL",
            10: "SIG_REAL_FUNC_INT_REAL_ARRAY",
            11: "SIG_SUB_2D_ARRAY",
            12: "SIG_SUB_REAL_2INT",
            13: "SIG_SUB_REAL_INT_4ARRAYS"
        }
        
    def discover_modern_functions(self) -> List[str]:
        """Discover all modernized functions from module files."""
        functions = []
        module_files = sorted(self.modern_dir.glob("*_module.f90"))
        
        for module_file in module_files:
            # Extract function name from filename
            match = re.match(r"(.+)_module\.f90$", module_file.name)
            if match:
                func_name = match.group(1)
                functions.append(func_name)
        
        return functions
    
    def parse_signatures(self) -> Dict[str, dict]:
        """Parse function signatures from slatec_signatures_module.f90."""
        signatures = {}
        
        with open(self.signatures_file, 'r') as f:
            content = f.read()
            
        # Find all function_info entries
        pattern = r"function_info\s*\(\s*&\s*name\s*=\s*'([^']+)'\s*,\s*&\s*signature_type\s*=\s*(\d+)"
        
        for match in re.finditer(pattern, content, re.MULTILINE | re.DOTALL):
            func_name = match.group(1).strip()
            sig_type = int(match.group(2))
            
            # Store normalized name (lowercase) -> signature info
            signatures[func_name.lower()] = {
                'name': func_name,
                'signature_type': sig_type,
                'signature_name': self.sig_types.get(sig_type, f"SIG_UNKNOWN_{sig_type}")
            }
            
        return signatures
    
    def check_f77_exists(self, func_name: str) -> bool:
        """Check if corresponding F77 source exists."""
        f77_path = self.src_dir / f"{func_name}.f"
        return f77_path.exists()
    
    def get_dependency_functions(self) -> List[str]:
        """Return list of known dependency functions."""
        # Add ENORM which we discovered is needed for QFORM
        return ['xermsg', 'ivout', 'j4save', 'xercnt', 'xerhlt', 'xerprn', 'xersve', 'xgetua', 'enorm']
    
    def generate_functions_inc(self, functions: List[str]) -> str:
        """Generate the functions.inc file with USE statements."""
        lines = [
            "! Automatically generated by discover_functions_v2.py",
            "! DO NOT EDIT MANUALLY",
            "",
            "    ! Modern function modules"
        ]
        
        for func in sorted(functions):
            lines.append(f"    use {func}_module, only: {func}_modern => {func}")
        
        return '\n'.join(lines)
    
    def generate_functions_mk(self, functions: List[str]) -> str:
        """Generate makefile variable definitions."""
        lines = [
            "# Automatically generated by discover_functions_v2.py",
            "# DO NOT EDIT MANUALLY",
            ""
        ]
        
        # Filter for functions that have F77 source
        valid_functions = [f for f in functions if self.check_f77_exists(f)]
        lines.append("DISCOVERED_FUNCTIONS = " + " ".join(sorted(valid_functions)))
        lines.append("")
        
        # Add dependency functions
        dep_funcs = self.get_dependency_functions()
        lines.append("DEPENDENCY_FUNCTIONS = " + " ".join(dep_funcs))
        lines.append("")
        
        # Combined list
        lines.append("ALL_TESTED_FUNCTIONS = $(DISCOVERED_FUNCTIONS) $(DEPENDENCY_FUNCTIONS)")
        
        return '\n'.join(lines)
    
    def generate_registration_routines(self, functions: List[str], signatures: Dict[str, dict]) -> str:
        """Generate the registration and dispatch routines."""
        lines = [
            "! Automatically generated by discover_functions_v2.py",
            "! DO NOT EDIT MANUALLY",
            "",
            "    subroutine register_discovered_functions()",
            "        ! Register which modern implementations are available"
        ]
        
        for func in sorted(functions):
            lines.append(f"        call register_modern('{func.upper()}', .true.)")
            
        lines.extend([
            "    end subroutine register_discovered_functions",
            ""
        ])
        
        return '\n'.join(lines)
    
    def generate_external_declarations(self, functions: List[str], signatures: Dict[str, dict]) -> str:
        """Generate external declarations for F77 functions grouped by signature type."""
        lines = [
            "! Automatically generated external declarations",
            "! DO NOT EDIT MANUALLY",
            ""
        ]
        
        # Group functions by signature type
        by_sig_type = {}
        for func in functions:
            sig_info = signatures.get(func, {})
            sig_type = sig_info.get('signature_type', 0)
            if sig_type not in by_sig_type:
                by_sig_type[sig_type] = []
            by_sig_type[sig_type].append(func)
        
        # Generate declarations for each signature type
        for sig_type in sorted(by_sig_type.keys()):
            if sig_type == 0:
                continue
                
            sig_name = self.sig_types.get(sig_type, f"SIG_UNKNOWN_{sig_type}")
            lines.append(f"    ! {sig_name}")
            
            for func in sorted(by_sig_type[sig_type]):
                if sig_type in [1, 5]:  # Real/Double function with 1 int
                    lines.append(f"    external :: {func}")
                elif sig_type in [2, 3]:  # Real function with 1 or 2 real
                    lines.append(f"    external :: {func}")
                elif sig_type == 4:  # Integer function with 1 int
                    lines.append(f"    external :: {func}")
                elif sig_type == 6:  # Logical function with 2 char
                    lines.append(f"    external :: {func}")
                elif sig_type >= 7:  # Subroutines
                    lines.append(f"    external :: {func}")
            
            lines.append("")
        
        return '\n'.join(lines)
    
    def generate_dispatcher_cases(self, functions: List[str], signatures: Dict[str, dict]) -> str:
        """Generate dispatcher case statements for each function."""
        lines = [
            "! Automatically generated dispatcher cases",
            "! DO NOT EDIT MANUALLY"
        ]
        
        # Group by signature type for more organized output
        by_sig_type = {}
        for func in functions:
            sig_info = signatures.get(func, {})
            sig_type = sig_info.get('signature_type', 0)
            if sig_type not in by_sig_type:
                by_sig_type[sig_type] = []
            by_sig_type[sig_type].append(func)
        
        # Generate select case entries for validate_* routines
        for sig_type in sorted(by_sig_type.keys()):
            if sig_type == 0:
                continue
                
            sig_name = self.sig_types.get(sig_type, f"SIG_UNKNOWN_{sig_type}")
            lines.append(f"")
            lines.append(f"    ! {sig_name} functions")
            
            for func in sorted(by_sig_type[sig_type]):
                lines.append(f"    case('{func.upper()}')")
                lines.append(f"        ! Handled by signature type {sig_type}")
        
        return '\n'.join(lines)
    
    def save_function_metadata(self, functions: List[str], signatures: Dict[str, dict]):
        """Save function metadata to JSON for other tools to use."""
        metadata = {}
        
        for func in functions:
            sig_info = signatures.get(func, {})
            metadata[func] = {
                'name': func.upper(),
                'has_f77': self.check_f77_exists(func),
                'signature_type': sig_info.get('signature_type', 0),
                'signature_name': sig_info.get('signature_name', 'UNKNOWN')
            }
        
        output_file = self.script_dir / "function_metadata.json"
        with open(output_file, 'w') as f:
            json.dump(metadata, f, indent=2, sort_keys=True)
        
        return output_file
    
    def run(self):
        """Run the discovery and generation process."""
        print("Enhanced Function Discovery Script")
        print("=" * 50)
        
        # Discover functions
        print("\nDiscovering modernized functions...")
        functions = self.discover_modern_functions()
        print(f"Found {len(functions)} modernized functions: {', '.join(sorted(functions))}")
        
        # Parse signatures
        print("\nParsing function signatures...")
        signatures = self.parse_signatures()
        print(f"Parsed {len(signatures)} function signatures")
        
        # Generate functions.inc
        print("\nGenerating include files...")
        functions_inc = self.generate_functions_inc(functions)
        output_file = self.script_dir / "functions.inc"
        output_file.write_text(functions_inc)
        print(f"✓ Generated {output_file}")
        
        # Generate functions.mk
        functions_mk = self.generate_functions_mk(functions)
        output_file = self.script_dir / "functions.mk"
        output_file.write_text(functions_mk)
        print(f"✓ Generated {output_file}")
        
        # Generate registration routines
        reg_routines = self.generate_registration_routines(functions, signatures)
        output_file = self.script_dir / "functions_routines.inc"
        output_file.write_text(reg_routines)
        print(f"✓ Generated {output_file}")
        
        # Generate external declarations
        externals = self.generate_external_declarations(functions, signatures)
        output_file = self.script_dir / "external_declarations.inc"
        output_file.write_text(externals)
        print(f"✓ Generated {output_file}")
        
        # Generate dispatcher cases  
        dispatcher = self.generate_dispatcher_cases(functions, signatures)
        output_file = self.script_dir / "dispatcher_cases.inc"
        output_file.write_text(dispatcher)
        print(f"✓ Generated {output_file}")
        
        # Save metadata
        metadata_file = self.save_function_metadata(functions, signatures)
        print(f"✓ Generated {metadata_file}")
        
        print("\nDone! All include files have been generated.")
        return True

if __name__ == "__main__":
    discovery = FunctionDiscovery()
    discovery.run()