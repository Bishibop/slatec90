{
  "name": "BSPLVN",
  "description": "Calculates the nonzero B-spline basis function values at a given point x for a specified order (up to jhigh) using the standard recurrence relation. It is designed to be called first with index = 1 (to initialize the basis function value) and then with index = 2 (to update the values) until the desired order is reached.",
  "algorithm_analysis": "The original Fortran 77 routine implements a recursive computation of B-spline basis functions. On the first call (when index equals 1) it initializes the order-1 basis function value to 1. On subsequent calls (index = 2) it uses the previous order\u2019s basis functions\u2014stored in the array VNIKX\u2014and updates them using differences computed from the knot vector T and the evaluation point x. Two temporary arrays (DELTAP and DELTAM) record the distances between knots and the point x and are stored with SAVE attributes to persist between calls. The recurrence loop runs from j = 1 until j equals the prescribed maximum order (jhigh), updating VNIKX in a way similar to the de Boor algorithm.",
  "modernization_notes": "Key changes include: \n1. Wrapping the functionality into a module and using 'implicit none' to enforce explicit declarations. \n2. Converting SAVE variables (J, DELTAM, DELTAP) into module-level variables which persist between calls. \n3. Replacing computed GOTO statements with a SELECT CASE construct. \n4. Adding INTENT declarations to all subroutine arguments. \n5. Removing DATA statements by initializing variables in their declaration. \n6. Structuring the looping constructs with modern DO WHILE loops, preserving the original mathematical behavior and precision.",
  "f90_code": "module BSplineModule\n  implicit none\n  \n  ! Module variables to maintain state between calls\n  integer, save :: j = 1\n  real, dimension(20), save :: deltam = 0.0\n  real, dimension(20), save :: deltap = 0.0\n  \n  public :: BSPLVN\n\ncontains\n\n  subroutine BSPLVN(t, jhigh, index, x, ileft, vnikx)\n    implicit none\n    ! Arguments\n    integer, intent(in) :: jhigh\n    integer, intent(in) :: index\n    integer, intent(in) :: ileft\n    real,    intent(in) :: x\n    real,    intent(in) :: t(:)\n    real,    intent(inout) :: vnikx(:)\n\n    ! Local variables\n    integer :: ipj, imjp1, jp1, JP1ML, L\n    real :: vmprev, vm, denom\n\n    select case (index)\n      case (1)\n        ! Initialization call: start with j = 1 and set first basis function\n        j = 1\n        vnikx(1) = 1.0\n        if (j >= jhigh) then\n          return\n        end if\n      case (2)\n        ! Continuation call: state maintained in module variable j\n        ! No initialization needed\n      case default\n        print *, \"Error in BSPLVN: Invalid index value (\", index, \") encountered. Expected index=1 or 2.\"\n        return\n    end select\n\n    do while (j < jhigh)\n      ipj = ileft + j\n      ! Compute the forward difference: distance between knot at position ipj and x\n      deltap(j) = t(ipj) - x\n\n      imjp1 = ileft - j + 1\n      ! Compute the backward difference: distance between x and knot at position imjp1\n      deltam(j) = x - t(imjp1)\n\n      vmprev = 0.0\n      jp1 = j + 1\n\n      do L = 1, j\n        JP1ML = jp1 - L\n        denom = deltap(L) + deltam(JP1ML)\n        ! It is assumed that denom is non-zero; otherwise, division-by-zero issues may occur.\n        vm = vnikx(L) / denom\n        vnikx(L) = vm * deltap(L) + vmprev\n        vmprev = vm * deltam(JP1ML)\n      end do\n      vnikx(jp1) = vmprev\n      j = jp1\n    end do\n\n    return\n  end subroutine BSPLVN\n\nend module BSplineModule\n",
  "elapsed_time": 53.16804099082947,
  "model": "o3-mini",
  "total_tokens": 5888,
  "cost": 0.010477,
  "validation": {
    "stdout": "Validating 200 test cases...\n",
    "stderr": "Traceback (most recent call last):\n  File \"/Users/nicholasmullen/Code/gauntlet/slatec_test/slatec_test_helper.py\", line 6048, in <module>\n    main()\n  File \"/Users/nicholasmullen/Code/gauntlet/slatec_test/slatec_test_helper.py\", line 6038, in main\n    success = helper.validate_modern()\n  File \"/Users/nicholasmullen/Code/gauntlet/slatec_test/slatec_test_helper.py\", line 5410, in validate_modern\n    results = self._run_modern_implementation(test_cases)\n  File \"/Users/nicholasmullen/Code/gauntlet/slatec_test/slatec_test_helper.py\", line 5593, in _run_modern_implementation\n    program = self._generate_modern_test_program(test_cases)\n  File \"/Users/nicholasmullen/Code/gauntlet/slatec_test/slatec_test_helper.py\", line 5655, in _generate_modern_test_program\n    return self._generate_bsplvn_modern_test(test_cases)\n  File \"/Users/nicholasmullen/Code/gauntlet/slatec_test/slatec_test_helper.py\", line 5943, in _generate_bsplvn_modern_test\n    t_array, jhigh, k, x, ileft, index_val = test['inputs']\nValueError: not enough values to unpack (expected 6, got 5)\n",
    "return_code": 1,
    "success": false
  }
}